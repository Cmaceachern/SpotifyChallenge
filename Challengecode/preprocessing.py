# -*- coding: utf-8 -*-
"""Preprocessing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1z6-1iNTDAjMFl-5vyVEqiMSPh5xceCM_
"""

import pandas as pd

import json

with open('/content/mpd.slice.0-999.json') as project_file:    
    data = json.load(project_file)  

df = pd.json_normalize(data)
df.to_csv (r'content', index = None)
print(df.head)

import csv
import json

with open('/content/mpd.slice.0-999.json') as json_file:
  data = json.load(json_file)

playlist_data = data['playlists']

data_file = open('mpd.slice.0-990.csv', 'w')

csv_writer = csv.writer(data_file)

count = 0;
for playlist in playlist_data:
  if count == 0:
    header = playlist.keys()
    csv_writer.writerow(playlist.values())

data_file.close()

from csv import writer
from csv import reader

"""Below two functions operate as Methods to update X,Y whenever it detects the songs in a given playlist"""

def onUpdateX(input_file, output_file, transform_row):
    """ Append a column in existing csv using csv.reader / csv.writer classes"""
    # Open the input_file in read mode and output_file in write mode
    with open(input_file, 'r') as read_obj, \
            open(output_file, 'w', newline='') as write_obj:
        # Create a csv.reader object from the input file object
        csv_reader = reader(read_obj)
        # Create a csv.writer object from the output file object
        csv_writer = writer(write_obj)
        # Read each row of the input csv file as list
        for row in csv_reader:
            # Pass the list / row in the transform function to add column text for this row
            transform_row(row, csv_reader.line_num)
            # Write the updated row / list to the output file
            csv_writer.writerow(row)

def onUpdateY(input_file, output_file, transform_row):
    """ Append a column in existing csv using csv.reader / csv.writer classes"""
    # Open the input_file in read mode and output_file in write mode
    with open(input_file, 'r') as read_obj, \
        open(output_file, 'w', newline='') as write_obj:
        # Create a csv.reader object from the input file object
        csv_reader = reader(read_obj)
        # Create a csv.writer object from the output file object
        csv_writer = writer(write_obj)
        # Read each row of the input csv file as list
        for row in csv_reader:
            # Pass the list / row in the transform function to add column text for this row
            transform_row(row, csv_reader.line_num)
            # Write the updated row / list to the output file
            csv_writer.writerow(row)

from csv import writer
from csv import reader

import random


with open('/0-999.csv', 'r') as read_obj, \
            open('output.csv', 'w', newline='') as write_obj:
        # Create a csv.reader object from the input file object
        csv_reader = reader(read_obj)
        # Create a csv.writer object from the output file object
        csv_writer = writer(write_obj)
        # Read each row of the input csv file as list
        for row in csv_reader:
            # Pass the list / row in the transform function to add column text for this row
            x = round(random.random(), 6)
            row.append(x)
            # Write the updated row / list to the output file
            csv_writer.writerow(row)

from csv import writer
from csv import reader

import random

with open('/content/output.csv', 'r') as read_obj, \
            open('output2.csv', 'w', newline='') as write_obj:
        # Create a csv.reader object from the input file object
        csv_reader = reader(read_obj)
        # Create a csv.writer object from the output file object
        csv_writer = writer(write_obj)
        # Read each row of the input csv file as list
        for row in csv_reader:

            # Pass the list / row in the transform function to add column text for this row
            y = round(random.random(), 6)
            row.append(y)
            # Write the updated row / list to the output file
            csv_writer.writerow(row)

"""Adding Headers"""

import pandas as pd

file = pd.read_csv('/content/output2.csv')
print("\nOriginal file:")
print(file)
  
# adding header
headerList = ['track_id', 'artist_name', 'track_name', 'pid', 'x_pos', 'y_pos']
  
# converting data frame to csv
file.to_csv("output2_headers.csv", header=headerList, index=False)
  
# display modified csv file
file2 = pd.read_csv("output2_headers.csv")
print('\nModified file:')
print(file2)

"""Drawing the initial graph"""

import matplotlib.pyplot as plt
plt.style.use('seaborn-whitegrid')
import numpy as np
plt.rcParams['agg.path.chunksize'] = 10000

x = []
y = []

with open('/content/output2.csv','r') as csvfile:
    plots = csv.reader(csvfile, delimiter=',')
    for row in plots:
        x.append(float(row[4]))
        y.append(float(row[5]))


plt.figure(figsize=(50, 50))
# plt.plot(x,y, label='Loaded from file!')


plt.xlabel('x')
plt.ylabel('y')
plt.title('Interesting Graph\nCheck it out')
plt.legend()
plt.yticks(np.arange(0, 1, .01))
plt.xticks(np.arange(0, 1, .01))
plt.scatter(x, y, c='black', alpha=0.5)
plt.show()

"""After Code has their initial placements on a graph - then starting the iterative process of them moving towards each other per playlist in the json file

"""



import pandas as pd



# making data frame from csv file
data = pd.read_csv("/content/output2_headers.csv")
 


# for label, content in data.iteritems():
#   tempListForValues = []
#   pidCount = 0

#   for i in content.values:
#     if(label =="pid" and i ==pidCount):

tempListForValues = []
for index, series in data.iterrows():
  pidCount = 0
  if(series.pid == pidCount):
    print(series)
    tempListForValues.append(series)

xt= []
yt = []

for song in tempListForValues:
  xt.append(song.x_pos)
  yt.append(song.y_pos)


plt.figure(figsize=(10, 10))
# plt.plot(xt,yt, label='Loaded from file!')


plt.xlabel('x')
plt.ylabel('y')
plt.title('Interesting Graph\nCheck it out')
plt.legend()
plt.yticks(np.arange(0, 1, .01))
plt.xticks(np.arange(0, 1, .01))
plt.scatter(xt, yt, c='black', alpha=0.5)

#Identifying the center

center = sum(xt)/len(xt), sum(yt)/len(yt)
plt.plot(center[0], center[1], marker='o')
plt.annotate(
   "center",
   xy=center, xytext=(-20, 20),
   textcoords='offset points', ha='right', va='bottom',
   bbox=dict(boxstyle='round,pad=0.5', fc='yellow', alpha=0.5),
   arrowprops=dict(arrowstyle='->', connectionstyle='arc3,rad=0'))

plt.show()

"""Creating a function to find out where the selected point is relative to the center point"""

def directionOfPoint(x_pos, y_pos, centerPoint):
  x,y = 0,0

  if(x_pos > center[0]):
    x=-1
  else:
    x=0

  if(y_pos > center[1]):
    y=-1
  else:
    y=1
  print()

  return x,y

"""Applying log(2) to everypoint towards the direction of the center point"""

import math
import pandas as pd



def changePosition(xt, yt, center):
  new_x, new_y = 0, 0
  x_vector, y_vector = 0,0

  x_vector, y_vector = directionOfPoint(xt,yt,center)
  # print('orig X value')
  # print(xt, yt)

  # print('Center')
  # print(center[0], center[1])

  # print(x_vector)
  new_x = xt + ((abs(xt - center[0]))* x_vector) / 2
  new_y = yt + ((abs(yt - center[1]))* y_vector) / 2

  return new_x, new_y

  # directionOfPoint(i, center)



xf,yf = 0,0
newUpdatedValues = []
tempListForValues = []

data = pd.read_csv("/content/output2_headers.csv")

for index, series in data.iterrows():
  # print(index,series)
  pidCount = 0
  if(series.pid == pidCount):
  # collect array of values with pid of 0
    # print(series)
    tempListForValues.append(series)


for song in tempListForValues:
  
  xf, yf = changePosition(song['x_pos'],song['y_pos'],center)

  song['x_pos'] = xf
  song['y_pos'] = yf

  newUpdatedValues.append(song)
  print()

# print('First List')

print()
print('New List')
print(newUpdatedValues[0].x_pos)
indexCount = 0
for row in data.itertuples():
  if row.pid == pidCount:
      data.at[indexCount, 'x_pos'] = newUpdatedValues[indexCount].x_pos
      data.at[indexCount, 'y_pos'] = newUpdatedValues[indexCount].y_pos
      indexCount += 1

for song in newUpdatedValues:
  for row in data.itertuples():
    if(song['track_name'] == row.track_name):
      data.loc['x_pos'].at[row.Index,song['x_pos'] ]
      data.loc['y_pos'].at[row.index,song['y_pos'] ]
data.to_csv("updated.csv", index=False)
        
    # else:
    #     df.at[i, 'ifor'] = y
# for index, series in data.iterrows():
#   condition = (data['pid'] == pidCount)
#   df.loc[condition,'x_pos'] = series.x_pos
  # df.loc[condition,'y_pos'] = series.y_pos




  # run reach value through the changing position function
  # collect the updated list
  # update every song that is in the data sheet with the new position
  # update the values from updated list with the values in the header.csv 
  # both the number of 0 pids and songs in the tempplaylist should be the same, therefore you can probably run a for loop to iterate over both of them 
  #   tempListForValues.append(series)

print(newUpdatedValues)
print(xt)

xff = []
yff = []
for song in newUpdatedValues:
  xff.append(song.x_pos)
  yff.append(song.y_pos)

print(xff)

plt.figure(figsize=(10, 10))
# plt.plot(xt,yt, label='Loaded from file!')


plt.xlabel('x')
plt.ylabel('y')
plt.title('Interesting Graph\nCheck it out')
plt.legend()
plt.yticks(np.arange(0, 1, .01))
plt.xticks(np.arange(0, 1, .01))
plt.scatter(xff, yff, c='black', alpha=0.5)

#Identifying the center

plt.plot(center[0], center[1], marker='o')
plt.annotate(
   "center",
   xy=center, xytext=(-20, 20),
   textcoords='offset points', ha='right', va='bottom',
   bbox=dict(boxstyle='round,pad=0.5', fc='yellow', alpha=0.5),
   arrowprops=dict(arrowstyle='->', connectionstyle='arc3,rad=0'))

plt.show()